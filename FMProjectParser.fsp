// Open the file that defines the type "expr" we shall use as AST
%{
open FMProjectTypesAST
%}

// Declare the tokens (terminal symbols)
%token <float> NUM
%token <string> VARIABLE
%token TIMES DIV PLUS MINUS POW LPAR RPAR EOF ROOT LN LOG LBRAK RBRAK
%token TRUE FALSE IFTHEN FATBAR
%token ASSIGN SKIP ORDER IF FI DO OD
%token BITWAND BITWOR AND OR NEG EQUAL NOTEQ GREATER LESS GREATEREQ LESSEQ
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)

%right ORDER FATBAR
%left PLUS MINUS
%left OR BITWOR
%left TIMES DIV
%left AND BITWAND
%right POW
%right NOT


// We declare the initial non-terminal symbol
%start start

// We specify the return type of each of then non-terminal symbols
%type <expr> start
%type <expr> expression
%type <expr> expression1
%type <boolExpr> boolexpression
%type <guardCommand> guardcom
%type <command> command

// Grammar productions
%%

// The first production in "formal" notation is
// start -> expression
// here written:
start: expression EOF             { $1 }

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:

//a ::= n | x | A[a] | a + a | a - a | a * a | a / a | - a | a ^ a | (a) 
expression:
  | expression TIMES expression     { TimesExpr($1,$3) }
  | expression DIV expression       { DivExpr($1,$3) }
  | expression PLUS expression      { PlusExpr($1,$3) }
  | expression MINUS expression     { MinusExpr($1,$3) }
  | expression POW expression       { PowExpr($1,$3) }
  | ROOT expression                 { RootExpr($2) }
  | LOG expression expression       { LogExpr($2,$3) } 
  | LN expression                   { LnExpr($2) }
  | VARIABLE LBRAK expression RBRAK { IndexExpr($1,$3) } 
  | expression1                     { $1 }

expression1:
  | PLUS expression1                { UPlusExpr($2) }
  | MINUS expression1               { UMinusExpr($2) }
  | NUM                             { Num($1) }
  | LPAR expression RPAR            { $2 }

//b ::= true | false | b & b | b | b | b && b | b || b | !b
//  | a = a | a != a | a > a | a >= a | a < a | a <= a | (b)
boolexpression:
  | TRUE                                    { True }
  | FALSE                                   { False }
  | boolexpression BITWAND boolexpression   { BitWiseAnd($1,$3) }
  | boolexpression BITWOR boolexpression    { BitWiseOr($1,$3) }
  | boolexpression AND boolexpression       { LogAnd($1,$3) }
  | boolexpression OR boolexpression        { LogOr($1,$3) }
  | NEG boolexpression                      { Neg($2)}
  | expression EQUAL expression             { Equal($1,$3) }
  | expression NOTEQ expression             { NotEqual($1,$3) }
  | expression GREATER expression           { Greater($1,$3) }
  | expression GREATEREQ expression         { GreaterEqual($1,$3) }
  | expression LESS expression              { Less($1,$3) }
  | expression LESSEQ expression            { LessEqual($1,$3) }
  | LPAR boolexpression RPAR                { $2 }

//GC ::= b -> C | GC [] GC
guardcom:
  | boolexpression IFTHEN command { IfThen($1,$3) }
  | guardcom FATBAR guardcom      { FatBar($1,$3) }

//C ::= x := a | A[a] := a | skip | C ; C | if GC fi | do GC od
command:
  | VARIABLE ASSIGN expression                        { Assign(Var($1),$3) }
  | VARIABLE LBRAK expression RBRAK ASSIGN expression { Assign(IndexExpr($1,$3),$6) }
  | SKIP                                              { Skip }
  | command ORDER command                             { Order($1,$3)}
  | IF guardcom FI                                    { If($2) }
  | DO guardcom OD                                    { Do($2) }

// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
